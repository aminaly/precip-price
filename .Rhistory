#get locations with the right set of dates
sorghum <- filter_dates(sorghum, "Sorghum")
head(sorghum)
nrow(sorghum$avg_rainfall > 0)
nrow(sorghum$avg_rainfall == 0)
count(sorghum$avg_rainfall == 0)
nrow(sorghum %>% filter(avg_rainfall == 0))
nrow(sorghum %>% filter(avg_rainfall < 1))
nrow(sorghum %>% filter(avg_rainfall > 1))
str_sub("hell", end = -3)
str_sub("hell0", end = -3)
str_sub("hello", end = -3)
str_sub("hello", end = -4)
str_sub("what tf is up, end = -4)
)
""
)
"
str_sub("what tf is up", end = -4)
head(sorghum)
a <- sorghum %>% filer(avg_rainfall >= 1)
a <- sorghum %>% filter(avg_rainfall >= 1)
a
head(a)
unique(a$avg_rainfall)
##calculate precip
#daily = True means you get daily average values rather than total accumulated precip
calc_precip <- function(data, daily=FALSE, zeros=TRUE) {
#check first to see if we've already calculated this.
grn <- data$type[1]
calcname <- ifelse(daily,paste0("precip/calc_", grn, "_", buf, "daily_ppdata.rds"), paste0("precip/calc_", grn, "_", buf, "_ppdata.rds"))
calcname <- ifelse(zeros, calcname, paste0(str_sub(calcname, end = -4), "_no_zeros.rds"))
if(file.exists(calcname)) return(readRDS(calcname))
#if we are removing zeros, let's get it out of the data now. It's really anything less than 1mm
if(!zeros) data <- data %>% filter(avg_rainfall >= 1)
data$p_sow <- 0
data$p_grow <- 0
data$p_harv <- 0
data$p_sup <- 0
for (i in 1:nrow(data))  {
cur_month <- as.numeric(data$month[i])
cur_yr <- as.numeric(data$year[i])
#sowing season
# if the current month is after the end of the (sowing) season, use this year.
#Otherwise use previous year's season is considered
yr <- ifelse(cur_month > data$se[i], cur_yr, cur_yr - 1)
#current logic assumes start and end dates happen in the same year
early_date <- as.Date(paste0(yr, "-", data$ss[i], "-01"), format = "%Y-%m-%d")
late_date <- as.Date(paste0(yr, "-", data$se[i], "-01"), format = "%Y-%m-%d")
rain_dates <- data %>%
filter(location == data$location[i]) %>%
filter(date >= early_date) %>%
filter(date <= late_date) %>%
group_by(country, location, product, date) %>%
summarise(avg_rainfall = mean(avg_rainfall, na.rm = T))
rain <- ifelse(daily, mean(rain_dates$avg_rainfall), sum(rain_dates$avg_rainfall))
data$p_sow[i] <- rain
#growing season
yr <- ifelse(cur_month > data$ge[i], cur_yr, cur_yr - 1)
early_date <- as.Date(paste0(yr, "-", data$gs[i], "-01"), format = "%Y-%m-%d")
late_date <- as.Date(paste0(yr, "-", data$ge[i], "-01"), format = "%Y-%m-%d")
rain_dates <- data %>%
filter(location == data$location[i]) %>%
filter(date >= early_date) %>%
filter(date <= late_date) %>%
group_by(country, location, product, date) %>%
summarise(avg_rainfall = mean(avg_rainfall, na.rm = T))
rain <- ifelse(daily, mean(rain_dates$avg_rainfall), sum(rain_dates$avg_rainfall))
data$p_grow[i] <- rain
#harvest season
yr <- ifelse(cur_month > data$he[i], cur_yr, cur_yr - 1)
early_date <- as.Date(paste0(yr, "-", data$hs[i], "-01"), format = "%Y-%m-%d")
late_date <- as.Date(paste0(yr, "-", data$he[i], "-01"), format = "%Y-%m-%d")
rain_dates <- data %>%
filter(location == data$location[i]) %>%
filter(date >= early_date) %>%
filter(date <= late_date) %>%
group_by(country, location, product, date) %>%
summarise(avg_rainfall = mean(avg_rainfall, na.rm = T))
rain <- ifelse(daily, mean(rain_dates$avg_rainfall), sum(rain_dates$avg_rainfall))
data$p_harv[i] <- rain
# between harvest and date of sale
# we don't update year because it is the same logic as the end of harvest szn
early_date <- late_date
late_date <- as.Date(data$date[i], format = "%Y-%m-%d")
rain_dates <- data %>%
filter(location == data$location[i]) %>%
filter(date >= early_date) %>%
#notice that we got rid of the equal to for the late date. Doesn't make sense for supply chain questions
filter(date < late_date) %>%
group_by(country, location, product, date) %>%
summarise(avg_rainfall = mean(avg_rainfall, na.rm = T))
rain <- ifelse(daily, mean(rain_dates$avg_rainfall), sum(rain_dates$avg_rainfall))
data$p_sup[i] <- rain
# prior month
# we don't update year because it is the same logic as the end of harvest szn
late_date <- as.Date(data$date[i], format = "%Y-%m-%d")
early_date <- seq(late_date, length = 2, by = "-1 months")[2]
rain_dates <- data %>%
filter(location == data$location[i]) %>%
filter(date >= early_date) %>%
#notice that we got rid of the equal to for the late date. Doesn't make sense for supply chain questions
filter(date < late_date) %>%
group_by(country, location, product, date) %>%
summarise(avg_rainfall = mean(avg_rainfall, na.rm = T))
rain <- ifelse(daily, mean(rain_dates$avg_rainfall), sum(rain_dates$avg_rainfall))
data$p_onemonth[i] <- rain
}
#Get rid of the first year, just there for calculation purposes
data <- data %>% filter(period_date >= min(period_date) + 365)
saveRDS(data, calcname)
return(data)
}
source('~/Documents/Stanford/precip-price/format_price.R', echo=TRUE)
# Source files with functions useful/data prep
price <- readRDS("saved-output/formatted-price.rds")
all_final <- c()
bufs <- c(.25,1,2)
#If you don't need to extract, just use this to get pp_data together. If you do, you'll need to run precip_extract
for(i in 1:3) {
buf <- bufs[i]
rdsname <- paste0("precip/", buf, "_precip.rds")
precip <- readRDS(rdsname)
precipname <- paste0("precip/", buf, "_ppdata.csv")
source('~/Documents/Stanford/precip-price/Functions for Analysis.R')
## Get data for each commodity
#lets get the sorghum we want specificially & merge in seasonality
sorghum <- filter_grain(pp_data, "Sorghum")
sorghum <- merge_seasons(sorghum, "sorghum")
#get locations with the right set of dates
sorghum <- filter_dates(sorghum, "Sorghum")
#calcualte precip for correct set of dates
sorghum <- calc_precip(sorghum, daily = TRUE, zeros = FALSE)
#lets get the millet we want specificially & merge in seasonality
millet <- filter_grain(pp_data, "Millet")
millet <- merge_seasons(millet, "millet")
#get locations with the right set of dates
millet <- filter_dates(millet, "Millet")
#calcualte precip for correct set of dates
millet <- calc_precip(millet, daily = TRUE, zeros = FALSE)
#lets get the maize we want specificially & merge in seasonality
maize <- filter_grain(pp_data, "Maize")
maize <- merge_seasons(maize, "maize")
#get locations with the right set of dates
maize <- filter_dates(maize, "Maize")
#calcualte precip for correct set of dates
maize <- calc_precip(maize, daily = TRUE, zeros = FALSE)
##### REGRESSIONS #####
## regress data with fixed effects
regress <- function(data, var, level) {
if(level == 1) {
switch(var,
"p_sow" = mod_data <- lm((def_value) ~ p_sow + as.factor(market) + as.factor(yrmnth), data=data),
"p_grow" = mod_data <- lm((def_value) ~ p_grow + as.factor(market) + as.factor(yrmnth), data=data),
"p_harv" = mod_data <- lm((def_value) ~ p_harv + as.factor(market) + as.factor(yrmnth), data=data),
"p_sup" = mod_data <- lm((def_value) ~ p_sup + as.factor(market) + as.factor(yrmnth), data=data),
"p_onemonth" = mod_data <- lm((def_value) ~ p_onemonth + as.factor(market) + as.factor(yrmnth), data=data))
} else if(level == "log") {
switch(var,
"p_sow" = mod_data <- lm((def_value) ~ log(p_sow) + as.factor(market) + as.factor(yrmnth), data=data),
"p_grow" = mod_data <- lm((def_value) ~ log(p_grow) + as.factor(market) + as.factor(yrmnth), data=data),
"p_harv" = mod_data <- lm((def_value) ~ log(p_harv) + as.factor(market) + as.factor(yrmnth), data=data),
"p_sup" = mod_data <- lm((def_value) ~ log(p_sup) + as.factor(market) + as.factor(yrmnth), data=data),
"p_onemonth" = mod_data <- lm((def_value) ~ log(p_onemonth) + as.factor(market) + as.factor(yrmnth), data=data))
} else {
switch(var,
"p_sow" = mod_data <- lm((def_value) ~ poly(p_sow,level,raw=T) + as.factor(market) + as.factor(yrmnth), data=data),
"p_grow" = mod_data <- lm((def_value) ~ poly(p_grow,level,raw=T) + as.factor(market) + as.factor(yrmnth), data=data),
"p_harv" = mod_data <- lm((def_value) ~ poly(p_harv,level,raw=T) + as.factor(market) + as.factor(yrmnth), data=data),
"p_sup" = mod_data <- lm((def_value) ~ poly(p_sup,level,raw=T) + as.factor(market) + as.factor(yrmnth), data=data),
"p_onemonth" = mod_data <- lm((def_value) ~ poly(p_onemonth,level,raw=T) + as.factor(market) + as.factor(yrmnth), data=data))
}
return(mod_data)
}
## regress using felm
regress_felm <- function(data, var, level) {
if(level == 1) {
switch(var,
"p_sow" = mod_data <- felm((def_value) ~ p_sow | market + yrmnth, data=data),
"p_grow" = mod_data <- felm((def_value) ~ p_grow | market + yrmnth, data=data),
"p_harv" = mod_data <- felm((def_value) ~ p_harv | market + yrmnth, data=data),
"p_sup" = mod_data <- felm((def_value) ~ p_sup | market + yrmnth, data=data),
"p_onemonth" = mod_data <- felm((def_value) ~ p_onemonth | market + yrmnth, data=data))
} else if(level == "log") {
switch(var,
"p_sow" = mod_data <- felm((def_value) ~ log(p_sow) | market + yrmnth, data=data),
"p_grow" = mod_data <- felm((def_value) ~ log(p_grow) | market + yrmnth, data=data),
"p_harv" = mod_data <- felm((def_value) ~ log(p_harv) | market + yrmnth, data=data),
"p_sup" = mod_data <- felm((def_value) ~ log(p_sup) | market + yrmnth, data=data),
"p_onemonth" = mod_data <- felm((def_value) ~ log(p_onemonth) | market + yrmnth, data=data))
} else {
switch(var,
"p_sow" = mod_data <- felm((def_value) ~ poly(p_sow,level,raw=T) | market + yrmnth, data=data),
"p_grow" = mod_data <- felm((def_value) ~ poly(p_grow,level,raw=T) | market + yrmnth, data=data),
"p_harv" = mod_data <- felm((def_value) ~ poly(p_harv,level,raw=T) | market + yrmnth, data=data),
"p_sup" = mod_data <- felm((def_value) ~ poly(p_sup,level,raw=T) | market + yrmnth, data=data),
"p_onemonth" = mod_data <- felm((def_value) ~ poly(p_onemonth,level,raw=T) | market + yrmnth, data=data))
}
return(mod_data)
}
## regress data with fixed effects
l_regress <- function(data, var, level) {
if(level == 1) {
switch(var,
"p_sow" = mod_data <- lm(log(def_value) ~ p_sow + as.factor(market) + as.factor(yrmnth), data=data),
"p_grow" = mod_data <- lm(log(def_value) ~ p_grow + as.factor(market) + as.factor(yrmnth), data=data),
"p_harv" = mod_data <- lm(log(def_value) ~ p_harv + as.factor(market) + as.factor(yrmnth), data=data),
"p_sup" = mod_data <- lm(log(def_value) ~ p_sup + as.factor(market) + as.factor(yrmnth), data=data),
"p_onemonth" = mod_data <- lm(log(def_value) ~ p_onemonth + as.factor(market) + as.factor(yrmnth), data=data))
} else if(level == "log") {
switch(var,
"p_sow" = mod_data <- lm(log(def_value) ~ log(p_sow) + as.factor(market) + as.factor(yrmnth), data=data),
"p_grow" = mod_data <- lm(log(def_value) ~ log(p_grow) + as.factor(market) + as.factor(yrmnth), data=data),
"p_harv" = mod_data <- lm(log(def_value) ~ log(p_harv) + as.factor(market) + as.factor(yrmnth), data=data),
"p_sup" = mod_data <- lm(log(def_value) ~ log(p_sup) + as.factor(market) + as.factor(yrmnth), data=data),
"p_onemonth" = mod_data <- lm(log(def_value) ~ log(p_onemonth) + as.factor(market) + as.factor(yrmnth), data=data))
} else {
switch(var,
"p_sow" = mod_data <- lm(log(def_value) ~ poly(p_sow,level,raw=T) + as.factor(market) + as.factor(yrmnth), data=data),
"p_grow" = mod_data <- lm(log(def_value) ~ poly(p_grow,level,raw=T) + as.factor(market) + as.factor(yrmnth), data=data),
"p_harv" = mod_data <- lm(log(def_value) ~ poly(p_harv,level,raw=T) + as.factor(market) + as.factor(yrmnth), data=data),
"p_sup" = mod_data <- lm(log(def_value) ~ poly(p_sup,level,raw=T) + as.factor(market) + as.factor(yrmnth), data=data),
"p_onemonth" = mod_data <- lm(log(def_value) ~ poly(p_onemonth,level,raw=T) + as.factor(market) + as.factor(yrmnth), data=data))
}
return(mod_data)
}
## regress using felm
l_regress_felm <- function(data, var, level) {
if(level == 1) {
switch(var,
"p_sow" = mod_data <- felm(log(def_value) ~ p_sow | market + yrmnth, data=data),
"p_grow" = mod_data <- felm(log(def_value) ~ p_grow | market + yrmnth, data=data),
"p_harv" = mod_data <- felm(log(def_value) ~ p_harv | market + yrmnth, data=data),
"p_sup" = mod_data <- felm(log(def_value) ~ p_sup | market + yrmnth, data=data),
"p_onemonth" = mod_data <- felm(log(def_value) ~ p_onemonth | market + yrmnth, data=data))
} else if(level == "log") {
switch(var,
"p_sow" = mod_data <- felm(log(def_value) ~ log(p_sow) | market + yrmnth, data=data),
"p_grow" = mod_data <- felm(log(def_value) ~ log(p_grow) | market + yrmnth, data=data),
"p_harv" = mod_data <- felm(log(def_value) ~ log(p_harv) | market + yrmnth, data=data),
"p_sup" = mod_data <- felm(log(def_value) ~ log(p_sup) | market + yrmnth, data=data),
"p_onemonth" = mod_data <- felm(log(def_value) ~ log(p_onemonth) | market + yrmnth, data=data))
} else {
switch(var,
"p_sow" = mod_data <- felm(log(def_value) ~ poly(p_sow,level,raw=T) | market + yrmnth, data=data),
"p_grow" = mod_data <- felm(log(def_value) ~ poly(p_grow,level,raw=T) | market + yrmnth, data=data),
"p_harv" = mod_data <- felm(log(def_value) ~ poly(p_harv,level,raw=T) | market + yrmnth, data=data),
"p_sup" = mod_data <- felm(log(def_value) ~ poly(p_sup,level,raw=T) | market + yrmnth, data=data),
"p_onemonth" = mod_data <- felm(log(def_value) ~ poly(p_onemonth,level,raw=T) | market + yrmnth, data=data))
}
return(mod_data)
}
## run linear, quad, and 3rd regression and make a table
commods <- list(sorghum, millet, maize)
types <- c("p_sow", "p_grow", "p_harv", "p_sup", "p_onemonth")
final <- c()
for(com in commods) {
for(t in types) {
#run the three regressions
linear <- regress(com, t, 1)
quad <- regress(com, t, 2)
third <- regress(com, t, 3)
log <- regress(com, t, "log")
#run logs
llinear <- l_regress(com, t, 1)
lquad <- l_regress(com, t, 2)
lthird <- l_regress(com, t, 3)
llog <- l_regress(com, t, "log")
#pvals?
#run the three regressions
flinear <- regress_felm(com, t, 1)
fquad <- regress_felm(com, t, 2)
fthird <- regress_felm(com, t, 3)
flog <- regress_felm(com, t, "log")
#run logs
fllinear <- l_regress_felm(com, t, 1)
flquad <- l_regress_felm(com, t, 2)
flthird <- l_regress_felm(com, t, 3)
fllog <- l_regress_felm(com, t, "log")
p_linear <- all(summary(flinear)$coefficients[,4] < 0.05)
p_quad <- all(summary(fquad)$coefficients[,4] < 0.05)
p_third <- all(summary(fthird)$coefficients[,4] < 0.05)
p_log <- all(summary(flog)$coefficients[,4] < 0.05)
p_llinear <- all(summary(fllinear)$coefficients[,4] < 0.05)
p_lquad <- all(summary(flquad)$coefficients[,4] < 0.05)
p_lthird <- all(summary(flthird)$coefficients[,4] < 0.05)
p_llog <- all(summary(fllog)$coefficients[,4] < 0.05)
gr <- as.character(com$type[1])
outcomes <- cbind(gr, t, AIC(linear), p_linear, AIC(quad), p_quad, AIC(third), p_third, AIC(log), p_log,
AIC(llinear), p_llinear, AIC(lquad), p_lquad, AIC(lthird), p_lthird, AIC(llog), p_llog)
final <- rbind(final, outcomes)
}
}
colnames(final) <- c("Grain", "Time Period", "Linear_AIC", "Linear_Pvals", "2_AIC", "2_Pvals", "3_AIC", "3_Pvals", "Log_AIC", "Log_Pvals",
"Log_Linear_AIC", "Log_Linear_Pvals", "Log_2_AIC", "Log_2_Pvals", "Log_3_AIC", "Log_3_Pvals", "Log_Log_AIC", "Log_Log_Pvals")
final <- as.data.frame(final)
final <- cbind(final, rep(buf, nrow(final)))
all_final <- rbind(all_final, final)
}
head(all_final)
write.csv(all_final, "model_comps_nozeros_split_nigeria.csv")
buf <- 1
rdsname <- paste0("precip/", buf, "_precip.rds")
precip <- readRDS(rdsname)
precipname <- paste0("precip/", buf, "_ppdata.csv")
## Get data for each commodity
#lets get the sorghum we want specificially & merge in seasonality
sorghum <- filter_grain(pp_data, "Sorghum")
sorghum <- merge_seasons(sorghum, "sorghum")
#get locations with the right set of dates
sorghum <- filter_dates(sorghum, "Sorghum")
#calcualte precip for correct set of dates
sorghum <- calc_precip(sorghum, daily = TRUE, zeros = FALSE)
#lets get the millet we want specificially & merge in seasonality
millet <- filter_grain(pp_data, "Millet")
millet <- merge_seasons(millet, "millet")
#get locations with the right set of dates
millet <- filter_dates(millet, "Millet")
#calcualte precip for correct set of dates
millet <- calc_precip(millet, daily = TRUE, zeros = FALSE)
#lets get the maize we want specificially & merge in seasonality
maize <- filter_grain(pp_data, "Maize")
maize <- merge_seasons(maize, "maize")
#get locations with the right set of dates
maize <- filter_dates(maize, "Maize")
#calcualte precip for correct set of dates
maize <- calc_precip(maize, daily = TRUE, zeros = FALSE)
ymaxs <- c(5, 1, 8, 2, .2)
ymins <- c(-.5, -1, -8, -2, -.5)
ys <- cbind(rep("sorghum", 5), ymaxs, ymins)
ymaxs <- c(1, 3, 50, 3, 1)
ymins <- c(-1, -3, -50, -10, -1)
ys <- rbind(ys, cbind(rep("millet", 5), ymaxs, ymins))
ymaxs <- c(1, 2, 50, .2, .2)
ymins <- c(-1, -1, -100, -1, -.5)
ys <- rbind(ys, cbind(rep("maize", 5), ymaxs, ymins))
par(mfrow=c(3,2))
comps <- read.csv("model-comps/Model_Comps_Master.csv", stringsAsFactors = F)
types <- c("p_sow", "p_grow", "p_harv", "p_sup", "p_onemonth")
#lib: 4 = standard, 5 = retail only, 6 = Daily Average, 7 = Daily Average No Days below 1mm
type <- 7
comps_plot <- comps %>% filter(Buffer == buf)
for(i in 1:nrow(comps_plot)) {
#select the current row, and make sure it's usable
row <- comps_plot[i,]
title <- paste(row$Grain, row$time_period, row[type], "buf=", buf, "> 0")
#If this is the first of a new section, plot just simple title before continuing
if((i %% 5) == 1) {
plot(c(0, 1), c(0, 1), ann = F, bty = 'n', type = 'n', xaxt = 'n', yaxt = 'n')
text(x = 0.5, y = 0.5, paste(row$Grain), cex = 1.6, col = "black")
}
#get the right data and level
data <- switch(row$Grain,
"sorghum" = sorghum,
"maize" = maize,
"millet" = millet)
level <- switch(as.character(row[type]),
"Log_Linear" = 1,
"Log_2" = 2,
"Log_3" = 3,
"Log_Log" = "log")
#if there is no level, plot title and move on
if(is.na(row[type])) {
plot(c(0, 1), c(0, 1), ann = F, bty = 'n', type = 'n', xaxt = 'n', yaxt = 'n')
text(x = 0.5, y = 0.5, paste(title, "No Ideal Model"), cex = 1.6, col = "black")
next
}
#get model and bootstrap
mod <- get_model_regression(data, row$time_period, level, log=TRUE)
boots <- bootstrap_data(data, mod, row$time_period, xrange=0:400, level=level, log=TRUE, short = T)
#plot with the title
x <- boots[[2]]
yy <- boots[[3]]
coef <- boots[[1]]
if(level == 2) {
plot(100,xlim=c(0,400),ylim=c(as.numeric(ys[i,3]),as.numeric(ys[i,2])),las=1,xlab="precip",ylab="value", main=title)
for (j in 1:100) {
yy <- x*coef[j,1] + x^2*coef[j,2]
yy <- yy - yy[x=80]
lines(x,yy,lwd=0.5)
}
} else if (level == 3) {
plot(100,xlim=c(0,400),ylim=c(as.numeric(ys[i,3]),as.numeric(ys[i,2])),las=1,xlab="precip",ylab="value", main=title)
for (j in 1:100) {
yy <- x*coef[j,1] + x^2*coef[j,2] + x^3*coef[j,3]
yy <- yy - yy[x=80]
lines(x,yy,lwd=0.5)
}
} else {
plot(100,xlim=c(0,400),ylim=c(as.numeric(ys[i,3]),as.numeric(ys[i,2])),las=1,xlab="precip",ylab="value", main=title)
for (i in 1:100) {
yy <- x*coef[j]
yy <- yy - yy[x=80]
lines(x,yy,lwd=0.5)
}
}
}
comps <- read.csv("model-comps/Model_Comps_Master.csv", stringsAsFactors = F)
types <- c("p_sow", "p_grow", "p_harv", "p_sup", "p_onemonth")
#lib: 4 = standard, 5 = retail only, 6 = Daily Average, 7 = Daily Average No Days below 1mm
type <- 7
comps_plot <- comps %>% filter(Buffer == buf)
for(i in 1:nrow(comps_plot)) {
#select the current row, and make sure it's usable
row <- comps_plot[i,]
title <- paste(row$Grain, row$time_period, row[type], "buf=", buf, "> 0")
#If this is the first of a new section, plot just simple title before continuing
if((i %% 5) == 1) {
plot(c(0, 1), c(0, 1), ann = F, bty = 'n', type = 'n', xaxt = 'n', yaxt = 'n')
text(x = 0.5, y = 0.5, paste(row$Grain), cex = 1.6, col = "black")
}
#get the right data and level
data <- switch(row$Grain,
"sorghum" = sorghum,
"maize" = maize,
"millet" = millet)
level <- switch(as.character(row[type]),
"Log_Linear" = 1,
"Log_2" = 2,
"Log_3" = 3,
"Log_Log" = "log")
#if there is no level, plot title and move on
if(is.na(row[type])) {
plot(c(0, 1), c(0, 1), ann = F, bty = 'n', type = 'n', xaxt = 'n', yaxt = 'n')
text(x = 0.5, y = 0.5, paste(title, "No Ideal Model"), cex = 1.6, col = "black")
next
}
#get model and bootstrap
mod <- get_model_regression(data, row$time_period, level, log=TRUE)
boots <- bootstrap_data(data, mod, row$time_period, xrange=0:400, level=level, log=TRUE, short = T)
#plot with the title
x <- boots[[2]]
yy <- boots[[3]]
coef <- boots[[1]]
if(level == 2) {
plot(100,xlim=c(0,400),ylim=c(as.numeric(ys[i,3]),as.numeric(ys[i,2])),las=1,xlab="precip",ylab="value", main=title)
for (j in 1:100) {
yy <- x*coef[j,1] + x^2*coef[j,2]
yy <- yy - yy[x=80]
lines(x,yy,lwd=0.5)
}
} else if (level == 3) {
plot(100,xlim=c(0,400),ylim=c(as.numeric(ys[i,3]),as.numeric(ys[i,2])),las=1,xlab="precip",ylab="value", main=title)
for (j in 1:100) {
yy <- x*coef[j,1] + x^2*coef[j,2] + x^3*coef[j,3]
yy <- yy - yy[x=80]
lines(x,yy,lwd=0.5)
}
} else {
plot(100,xlim=c(0,400),ylim=c(as.numeric(ys[i,3]),as.numeric(ys[i,2])),las=1,xlab="precip",ylab="value", main=title)
for (i in 1:100) {
yy <- x*coef[j]
yy <- yy - yy[x=80]
lines(x,yy,lwd=0.5)
}
}
}
for(i in 1:nrow(comps_plot)) {
#select the current row, and make sure it's usable
row <- comps_plot[i,]
title <- paste(row$Grain, row$time_period, row[type], "buf=", buf, "> 0")
#If this is the first of a new section, plot just simple title before continuing
if((i %% 5) == 1) {
plot(c(0, 1), c(0, 1), ann = F, bty = 'n', type = 'n', xaxt = 'n', yaxt = 'n')
text(x = 0.5, y = 0.5, paste(row$Grain), cex = 1.6, col = "black")
}
#get the right data and level
data <- switch(row$Grain,
"sorghum" = sorghum,
"maize" = maize,
"millet" = millet)
level <- switch(as.character(row[type]),
"Log_Linear" = 1,
"Log_2" = 2,
"Log_3" = 3,
"Log_Log" = "log")
#if there is no level, plot title and move on
if(is.na(row[type])) {
plot(c(0, 1), c(0, 1), ann = F, bty = 'n', type = 'n', xaxt = 'n', yaxt = 'n')
text(x = 0.5, y = 0.5, paste(title, "No Ideal Model"), cex = 1.6, col = "black")
next
}
#get model and bootstrap
mod <- get_model_regression(data, row$time_period, level, log=TRUE)
boots <- bootstrap_data(data, mod, row$time_period, xrange=0:400, level=level, log=TRUE, short = T)
#plot with the title
x <- boots[[2]]
yy <- boots[[3]]
coef <- boots[[1]]
if(level == 2) {
plot(100,xlim=c(0,400),ylim=c(as.numeric(ys[i,3]),as.numeric(ys[i,2])),las=1,xlab="precip",ylab="value", main=title)
for (j in 1:100) {
yy <- x*coef[j,1] + x^2*coef[j,2]
yy <- yy - yy[x=80]
lines(x,yy,lwd=0.5)
}
} else if (level == 3) {
plot(100,xlim=c(0,400),ylim=c(as.numeric(ys[i,3]),as.numeric(ys[i,2])),las=1,xlab="precip",ylab="value", main=title)
for (j in 1:100) {
yy <- x*coef[j,1] + x^2*coef[j,2] + x^3*coef[j,3]
yy <- yy - yy[x=80]
lines(x,yy,lwd=0.5)
}
} else {
plot(100,xlim=c(0,400),ylim=c(as.numeric(ys[i,3]),as.numeric(ys[i,2])),las=1,xlab="precip",ylab="value", main=title)
for (i in 1:100) {
yy <- x*coef[j]
yy <- yy - yy[x=80]
lines(x,yy,lwd=0.5)
}
}
}
