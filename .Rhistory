install.packages("dataseries")
install.packages("datasets.load")
library(datasets)
?datasets
data("iris")
data(iris)
summary(iris)
a <- data(iris)
iew(iris)
View(data("iris"))
View(data(iris))
View(iris)
summary(iris)
summary(iris)
install.packages("data.table")
as.data.table(iris)
library(data.table)
summary(iris)
as.data.table(iris)
iris
as.data.table(iris)
iris[Sepal.Width > 3]
iris <- as.data.table(iris)
iris[Sepal.Width > 3]
iris[Sepal.Width > 4,.(Sepal.Length, Species)]
sepal_greater_three <- iris[Sepal.Width > 3]
iris
sepal_greater_three
#give me petal.length and petal.width + 1 for every record with a sepal.length
#greater than 5 BY species
iris[Sepal.Length > 5,.(PL = sum(Petal.Length), PW = sum(Petal.Width)),.(Species)]
install.packages("extRemes")
?extRemes
?extremes
library(extRemes)
?extRemes
data(HEAT)
HEAT
?return.level
?fevd
fevd(HEAT)
fevd(HEAT[,1])
HEAT <- as.data.table(HEAT)
f_heat <- fevd(HEAT[,Tmax])
return.level(f_heat, c(5,10,50))
return.level(f_heat, c(5,15,50))
return.level(f_heat, c(1, 5,15,50))
return.level(f_heat, c(2, 5,15,50))
return.level(f_heat, c(2, 5,15,50, 200))
118/116
200 / 116
install.packages("ncdf4")
ftp://ftp.cdc.noaa.gov/Datasets/cpc_global_precip/precip.1979.nc
library(ncdf4)
download.file("ftp://ftp.cdc.noaa.gov/Datasets/cpc_global_precip/precip.1979.nc", "here.nc")
precip <- nc_open("here.nc")
precip
water <- ncvar_get(precip)
water
?ncvar_get
download.file("ftp://ftp.cdc.noaa.gov/Datasets/cpc_global_precip/precip.1990.nc", "here.nc")
precip <- nc_open("here.nc")
water <- ncvar_get(precip)
View(water)
water
install.packages("ismev")
library(ismev)
install.packages("extRemes")
install.packages("extRemes")
install.packages("extRemes")
R.home()
install.packages("ismev", lib  = "/Users/amina/anaconda2/lib/R/library")
install.packages("extRemes", lib = "/Users/amina/anaconda2/lib/R/library")
install.packages("extRemes", lib = "/Users/amina/anaconda2/lib/R/library")
install.packages("extRemes", lib = "/Users/amina/anaconda2/lib/R/library")
install.packages("mgcv", lib = "/Users/amina/anaconda2/lib/R/library")
install.packages("mgcv", lib = "/Users/amina/anaconda2/lib/R/library")
install.packages("nlme", lib = "/Users/amina/anaconda2/lib/R/library")
install.packages("nlme", lib = "/Users/amina/anaconda2/lib/R/library")
install.packages("lattice", lib = "/Users/amina/anaconda2/lib/R/library")
install.packages("lattice", lib = "/Users/amina/anaconda2/lib/R/library")
detach("package:graphics", unload=TRUE)
detach("package:grDevices", unload=TRUE)
detach("package:methods", unload=TRUE)
detach("package:stats", unload=TRUE)
detach("package:utils", unload=TRUE)
install.packages("Matrix", lib = "/Users/amina/anaconda2/lib/R/library")
install.packages(c("car", "data.table", "digest", "DT", "htmlwidgets", "lme4", "MASS", "Matrix", "mgcv", "nlme", "quantreg", "Rcpp", "RcppEigen", "rpart", "yaml"))
library("tools", lib.loc="/Library/Frameworks/R.framework/Versions/3.4/Resources/library")
install.packages("Matrix", lib = "/Users/amina/anaconda2/lib/R/library")
install.packages("Matrix", lib = "/Users/amina/anaconda2/lib/R/library")
install.packages("Matrix", lib = "/Users/amina/anaconda2/lib/R/library")
library(extRemes)
val <- 7.392210
fevd(val, verbose=T)
debug(fevd)
library(extRemes)
val <- 7.392210
fevd(val, verbose=T)
ipars2
?fevd
data <- read.csv("/Users/amina/Documents/example.csv")
data
?file.exists
?tryCatch
tryCatch(stop(e), error = function(e) e, finally = print("Hello"))
e <- 44
tryCatch(stop(e), error = function(e) e, finally = print("Hello"))
}
?if
)
??if
)
source('~/Documents/Stanford/R - Spring 2019/New Regressions.R')
## SORGHUM
#lets get the sorghum we want specificially & merge in seasonality
sorghum <- filter_grain(pp_data, "Sorghum")
sorghum <- merge_seasons(sorghum, "sorghum")
#get locations with the right set of dates
sorghum <- filter_dates(sorghum, "Sorghum")
#calcualte precip for correct set of dates
#doing this first because otherwise we end up with some zeros at the end
sorghum <- calc_precip(sorghum)
source('~/Documents/Stanford/R - Spring 2019/New Regressions.R')
rm(list=ls())
library(dplyr)
library(ggmap)
library(gridExtra)
library(stringr)
library(lucr)
library(reshape2)
library(sf)
library(raster)
library(velox)
library(mapview)
library(lfe)
library(lubridate)
buf <- 2
setwd("~/Desktop/data/")
source('~/Documents/Stanford/R - Spring 2019/New Regressions.R')
rm(list=ls())
library(dplyr)
library(ggmap)
library(gridExtra)
library(stringr)
library(lucr)
library(reshape2)
setwd("~/Desktop/data/")
prc <- read.csv("PriceData.csv")
loc <- read.csv("locations.csv")
## Clean up price data to get it in the format you'd like and join with locations
price <- prc %>% filter(product_source == "Local") %>%
filter(country != "Haiti")
## Removing non-ag things
price <- price[!str_detect(price$product,
c("us", "Labor", "Cattle", "Goats",
"Sheep", "Beef", "Camel", "Fish",
"Gasoline", "Diesel", "Palm")),]
price$period_date <- as.Date(price$period_date, format="%m/%d/%y")
## Fix currencies so they're more consistent
## Add in some year and location data
price$location <- paste0(price$country, ", ", price$market)
price$year <- format(as.Date(price$period_date, format="%m/%d/%y"),"%Y")
price <- left_join(price, loc, by = "location")
## Download price conversion rates and deflation calculator
prc_conv <- read.csv("price_conversion.csv")
def_conv <- read.csv("deflation_vals/deflation_calc.csv", check.names = F)
## Format deflation data
def_conv <- melt(def_conv, na.rm = T)
def_conv <- def_conv %>%
dplyr::select("Country Name", "Country Code", "Indicator Name", "variable", "value") %>%
rename(deflation_calc = value)
## Calculate deflated rates
price2 <- left_join(price, def_conv, by = c("country"="Country Name", "year" = "variable"))
price2 <- price2 %>% filter(!is.na(deflation_calc))
price2$def_value <- price2$value / (price2$deflation_calc / 100)
## Calculate USD value
#price2 <- left_join(price2, prc_conv, by = "currency")
#price2$us_value <- price2$value / price2$usd
# Clean up unusable data
price2 <- price2[which(!is.na(price2$latitude)),]
# Adjust dates
price2$period_date <- as.Date(price2$period_date, format = "%Y-%m-%d")
price2$month <- format(price2$period_date, "%m")
price2 <- price2 %>% mutate(def_value = ifelse(unit == "100_kg", def_value/100, def_value))
price <- price2
library(sf)
library(raster)
library(velox)
library(mapview)
library(lfe)
library(lubridate)
buf <- 2
setwd("~/Desktop/data/")
source('~/Documents/Stanford/R - Spring 2019/New Regressions.R')
## SORGHUM
#lets get the sorghum we want specificially & merge in seasonality
sorghum <- filter_grain(pp_data, "Sorghum")
sorghum <- merge_seasons(sorghum, "sorghum")
#Clean up the precip data a little bit
clean_precip <- function(precip) {
precip$date <- as.Date(precip$date, format = "%Y.%m.%d")
precip$month <-  format(precip$date, "%m")
precip$year <- format(precip$date, "%Y")
precip <- precip[which(!is.na(precip$temp_mean)),]
precip <- precip %>% filter(format(precip$date, "%Y") > 1993) %>% rename(avg_rainfall = temp_mean)
pp_data <- left_join(price, precip, by = c("month", "market" = "location", "year"))
pp_data <- pp_data %>% filter(!is.na(avg_rainfall)) %>% filter(!is.na(value)) %>% filter(def_value != 0)
pp_data$yrmnth <- paste0(pp_data$year, " ", pp_data$month)
write.csv(pp_data, file = precipname)
return(pp_data)
}
pp_data <- ifelse(file.exists(precipname), read.csv(precipname), clean_precip(precip))
## SORGHUM
#lets get the sorghum we want specificially & merge in seasonality
sorghum <- filter_grain(pp_data, "Sorghum")
pp_data
head(pp_data)
rm(list=ls())
library(dplyr)
library(ggmap)
library(gridExtra)
library(stringr)
library(lucr)
library(reshape2)
setwd("~/Desktop/data/")
prc <- read.csv("PriceData.csv")
loc <- read.csv("locations.csv")
## Clean up price data to get it in the format you'd like and join with locations
price <- prc %>% filter(product_source == "Local") %>%
filter(country != "Haiti")
## Removing non-ag things
price <- price[!str_detect(price$product,
c("us", "Labor", "Cattle", "Goats",
"Sheep", "Beef", "Camel", "Fish",
"Gasoline", "Diesel", "Palm")),]
price$period_date <- as.Date(price$period_date, format="%m/%d/%y")
## Fix currencies so they're more consistent
## Add in some year and location data
price$location <- paste0(price$country, ", ", price$market)
price$year <- format(as.Date(price$period_date, format="%m/%d/%y"),"%Y")
price <- left_join(price, loc, by = "location")
## Download price conversion rates and deflation calculator
prc_conv <- read.csv("price_conversion.csv")
def_conv <- read.csv("deflation_vals/deflation_calc.csv", check.names = F)
## Format deflation data
def_conv <- melt(def_conv, na.rm = T)
def_conv <- def_conv %>%
dplyr::select("Country Name", "Country Code", "Indicator Name", "variable", "value") %>%
rename(deflation_calc = value)
## Calculate deflated rates
price2 <- left_join(price, def_conv, by = c("country"="Country Name", "year" = "variable"))
price2 <- price2 %>% filter(!is.na(deflation_calc))
price2$def_value <- price2$value / (price2$deflation_calc / 100)
## Calculate USD value
#price2 <- left_join(price2, prc_conv, by = "currency")
#price2$us_value <- price2$value / price2$usd
# Clean up unusable data
price2 <- price2[which(!is.na(price2$latitude)),]
# Adjust dates
price2$period_date <- as.Date(price2$period_date, format = "%Y-%m-%d")
price2$month <- format(price2$period_date, "%m")
price2 <- price2 %>% mutate(def_value = ifelse(unit == "100_kg", def_value/100, def_value))
price <- price2
library(sf)
library(raster)
library(velox)
library(mapview)
library(lfe)
library(lubridate)
buf <- 2
setwd("~/Desktop/data/")
library(lfe)
#If you don't need to extract, just use this to get pp_data together
buf <- 2
setwd("~/Desktop/data/")
rdsname <- paste0(buf, "_precip.rds")
precip <- readRDS(rdsname)
precipname <- paste0(buf, "_ppdata.csv")
#Clean up the precip data a little bit
clean_precip <- function(precip) {
precip$date <- as.Date(precip$date, format = "%Y.%m.%d")
precip$month <-  format(precip$date, "%m")
precip$year <- format(precip$date, "%Y")
precip <- precip[which(!is.na(precip$temp_mean)),]
precip <- precip %>% filter(format(precip$date, "%Y") > 1993) %>% rename(avg_rainfall = temp_mean)
pp_data <- left_join(price, precip, by = c("month", "market" = "location", "year"))
pp_data <- pp_data %>% filter(!is.na(avg_rainfall)) %>% filter(!is.na(value)) %>% filter(def_value != 0)
pp_data$yrmnth <- paste0(pp_data$year, " ", pp_data$month)
write.csv(pp_data, file = precipname)
return(pp_data)
}
pp_data <- ifelse(file.exists(precipname), read.csv(precipname), clean_precip(precip))
## SORGHUM
#lets get the sorghum we want specificially & merge in seasonality
sorghum <- filter_grain(pp_data, "Sorghum")
head(pp_data)
precipname
pp_data <- ifelse(file.exists(precipname), read.csv(precipname, header = T, stringsAsFactors = F), clean_precip(precip))
head(pp_data)
as.data.frame(pp_data)
head(as.data.table(pp_data))
#pp_data <- ifelse(file.exists(precipname), read.csv(precipname, header = T, stringsAsFactors = F), clean_precip(precip))
pp_data <- clean_precip(precip)
pp_data
head(pp_data)
typeof(pp_data)
class(pp_data)
pp_data <- ifelse(file.exists(precipname), read.csv(precipname, header = T, stringsAsFactors = F), clean_precip(precip))
#divide deflation by 100, then devide rpie y that
#run log of the converted value not the usd con
head(pp_data)
pp_data <- ifelse(file.exists(precipname), read.csv(precipname, header = T, stringsAsFactors = F, sep = ","), clean_precip(precip))
head(pp_data)
class(pp_data)
unlist(pp_data)
head(as.data.frame(pp_data))
library(lfe)
#If you don't need to extract, just use this to get pp_data together
buf <- 2
setwd("~/Desktop/data/")
rdsname <- paste0("precip/", buf, "_precip.rds")
precip <- readRDS(rdsname)
precipname <- paste0("precip/", buf, "_ppdata.csv")
#Clean up the precip data a little bit
clean_precip <- function(precip) {
precip$date <- as.Date(precip$date, format = "%Y.%m.%d")
precip$month <-  format(precip$date, "%m")
precip$year <- format(precip$date, "%Y")
precip <- precip[which(!is.na(precip$temp_mean)),]
precip <- precip %>% filter(format(precip$date, "%Y") > 1993) %>% rename(avg_rainfall = temp_mean)
pp_data <- left_join(price, precip, by = c("month", "market" = "location", "year"))
pp_data <- pp_data %>% filter(!is.na(avg_rainfall)) %>% filter(!is.na(value)) %>% filter(def_value != 0)
pp_data$yrmnth <- paste0(pp_data$year, " ", pp_data$month)
write.csv(pp_data, file = precipname)
return(pp_data)
}
pp_data <- clean_precip(precip)
library(lfe)
#If you don't need to extract, just use this to get pp_data together
buf <- 2
setwd("~/Desktop/data/")
rdsname <- paste0("precip/", buf, "_precip.rds")
precip <- readRDS(rdsname)
precipname <- paste0("precip/", buf, "_ppdata.csv")
#Clean up the precip data a little bit
clean_precip <- function(precip) {
precip$date <- as.Date(precip$date, format = "%Y.%m.%d")
precip$month <-  format(precip$date, "%m")
precip$year <- format(precip$date, "%Y")
precip <- precip[which(!is.na(precip$temp_mean)),]
precip <- precip %>% filter(format(precip$date, "%Y") > 1993) %>% rename(avg_rainfall = temp_mean)
pp_data <- left_join(price, precip, by = c("month", "market" = "location", "year"))
pp_data <- pp_data %>% filter(!is.na(avg_rainfall)) %>% filter(!is.na(value)) %>% filter(def_value != 0)
pp_data$yrmnth <- paste0(pp_data$year, " ", pp_data$month)
return(pp_data)
}
pp_data <- clean_precip(precip)
head(pp_data)
source('~/Documents/Stanford/R - Spring 2019/New Regressions.R')
## SORGHUM
#lets get the sorghum we want specificially & merge in seasonality
sorghum <- filter_grain(pp_data, "Sorghum")
sorghum <- merge_seasons(sorghum, "sorghum")
#get locations with the right set of dates
sorghum <- filter_dates(sorghum, "Sorghum")
#calcualte precip for correct set of dates
#doing this first because otherwise we end up with some zeros at the end
sorghum <- calc_precip(sorghum)
#calcualte precip for correct set of dates
#doing this first because otherwise we end up with some zeros at the end
sorghum <- calc_precip(sorghum)
data$month
data$date
data$date[1]
typeof(data$date[1])
class(data$date[1])
a <- data$date[1]
seq(a, length = 2, by = "-1 months")
seq(a, length = 1, by = "-1 months")
seq(a, length = 1, by = "-2 months")
seq(a, length = 2, by = "-1 months")
seq(a, length = 2, by = "-1 months")[2]
source('~/Documents/Stanford/R - Spring 2019/New Regressions.R')
source('~/Documents/Stanford/R - Spring 2019/New Regressions.R')
## SORGHUM
#lets get the sorghum we want specificially & merge in seasonality
sorghum <- filter_grain(pp_data, "Sorghum")
sorghum <- merge_seasons(sorghum, "sorghum")
#get locations with the right set of dates
sorghum <- filter_dates(sorghum, "Sorghum")
#calcualte precip for correct set of dates
#doing this first because otherwise we end up with some zeros at the end
sorghum <- calc_precip(sorghum)
plot(sorghum$avg_rainfall, sorghum$p_onemonth)
mod_sorghum_onem <- quad_regression(sorghum, "p_onemonth")
source('~/Documents/Stanford/R - Spring 2019/New Regressions.R')
mod_sorghum_onem <- quad_regression(sorghum, "p_onemonth")
summary(mod_sorghum_onem)
source('~/Documents/Stanford/R - Spring 2019/New Regressions.R')
sorghum_sup_boot <- bootstrap_data_lin(sorghum, mod_sorghum_onem, "p_onemonth")
mod_sorghum_onem <- quad_regression(sorghum, "p_onemonth")
sorghum_sup_boot <- bootstrap_data_lin(sorghum, mod_sorghum_onem, "p_onemonth")
source('~/Documents/Stanford/R - Spring 2019/New Regressions.R')
sorghum_sup_boot <- bootstrap_data_lin(sorghum, mod_sorghum_onem, "p_onemonth")
sorghum_sup_boot <- bootstrap_data_lin(sorghum, mod_sorghum_onem, "p_onemonth")
source('~/Documents/Stanford/R - Spring 2019/New Regressions.R')
sorghum_sup_boot <- bootstrap_data_lin(sorghum, mod_sorghum_onem, "p_onemonth")
_
sorghum_sup_boot <- bootstrap_data(sorghum, mod_sorghum_onem, "p_onemonth")
##This isn't output anywhere permanantly. change at will
x <- sorghum_onem_boot[[2]]
yy <- sorghum_onem_boot[[3]]
coef <- sorghum_onem_boot[[1]]
plot(100,xlim=c(0,700),ylim=c(-.1,.5),las=1,xlab="precip",ylab="value")
for (i in 1:100) {
yy <- x*coef[i] + x^2*coef[i,2]
yy <- yy - yy[x=80]
lines(x,yy,lwd=0.5)
}
sorghum_onem_boot <- sorghum_sup_boot
##This isn't output anywhere permanantly. change at will
x <- sorghum_onem_boot[[2]]
yy <- sorghum_onem_boot[[3]]
coef <- sorghum_onem_boot[[1]]
plot(100,xlim=c(0,700),ylim=c(-.1,.5),las=1,xlab="precip",ylab="value")
for (i in 1:100) {
yy <- x*coef[i] + x^2*coef[i,2]
yy <- yy - yy[x=80]
lines(x,yy,lwd=0.5)
}
x <- sorghum_onem_boot[[2]]
yy <- sorghum_onem_boot[[3]]
coef <- sorghum_onem_boot[[1]]
plot(100,xlim=c(0,700),ylim=c(-.1,.5),las=1,xlab="precip",ylab="value")
for (i in 1:100) {
yy <- x*coef[i] + x^2*coef[i,2]
#yy <- yy - yy[x=80]
lines(x,yy,lwd=0.5)
}
plot(sorghum$avg_rainfall, sorghum$p_onemonth)
source('~/Documents/Stanford/R - Spring 2019/New Regressions.R')
sorghum_onem_boot <- bootstrap_data(sorghum, mod_sorghum_onem, "p_onemonth", short = T)
##This isn't output anywhere permanantly. change at will
x <- sorghum_onem_boot[[2]]
yy <- sorghum_onem_boot[[3]]
coef <- sorghum_onem_boot[[1]]
plot(100,xlim=c(0,700),ylim=c(-.1,.5),las=1,xlab="precip",ylab="value")
for (i in 1:100) {
yy <- x*coef[i] + x^2*coef[i,2]
#yy <- yy - yy[x=80]
lines(x,yy,lwd=0.5)
}
source('~/Documents/Stanford/R - Spring 2019/New Regressions.R')
sorghum_onem_boot <- bootstrap_data(sorghum, mod_sorghum_onem, "p_onemonth", short = T)
##This isn't output anywhere permanantly. change at will
x <- sorghum_onem_boot[[2]]
yy <- sorghum_onem_boot[[3]]
coef <- sorghum_onem_boot[[1]]
plot(100,xlim=c(0,400),ylim=c(-.1,.5),las=1,xlab="precip",ylab="value")
for (i in 1:100) {
yy <- x*coef[i] + x^2*coef[i,2]
#yy <- yy - yy[x=80]
lines(x,yy,lwd=0.5)
}
## Mill
source('~/Documents/Stanford/R - Spring 2019/New Regressions.R')
source('~/Documents/Stanford/R - Spring 2019/New Regressions.R')
head(pp_data)
unique(pp_data$price_type)
source('~/Documents/Stanford/precip-price/Functions for Analysis.R')
getwd()
Macintosh HD⁩ ▸ ⁨Users⁩ ▸ ⁨amina⁩ ▸ ⁨Documents⁩ ▸ ⁨Stanford⁩
setwd("/Users/amina/Documents/Stanford/precip-price")
source('~/Documents/Stanford/precip-price/Functions for Analysis.R')
mod_sorghum_sow <- linear_regression_interaction(sorghum, "p_sow")
summary(mod_sorghum_sow)
#bootstrap all three and return information for plotting
sorghum_sow_boot <- bootstrap_data_lin(sorghum, mod_sorghum_sow, "p_sow")
#bootstrap all three and return information for plotting
sorghum_sow_boot <- bootstrap_data_lin(sorghum, mod_sorghum_sow, "p_sow", short = T)
x <- sorghum_sow_boot[[2]]
yy <- sorghum_sow_boot[[3]]
coef <- sorghum_sow_boot[[1]]
plot(100,xlim=c(0,400),ylim=c(-.1,.5),las=1,xlab="precip",ylab="value")
for (i in 1:100) {
yy <- x*coef[i] + x^2*coef[i,2]
#yy <- yy - yy[x=80]
lines(x,yy,lwd=0.5)
}
plot(100,xlim=c(0,400),ylim=c(-.1,10),las=1,xlab="precip",ylab="value")
for (i in 1:100) {
yy <- x*coef[i] + x^2*coef[i,2]
#yy <- yy - yy[x=80]
lines(x,yy,lwd=0.5)
}
# panel regression
mod_sorghum_sow <- linear_regression(sorghum, "p_sow")
#bootstrap all three and return information for plotting
sorghum_sow_boot <- bootstrap_data_lin(sorghum, mod_sorghum_sow, "p_sow", short = T)
##This isn't output anywhere permanantly. change at will
x <- sorghum_sow_boot[[2]]
yy <- sorghum_sow_boot[[3]]
coef <- sorghum_sow_boot[[1]]
plot(100,xlim=c(0,400),ylim=c(-.1,10),las=1,xlab="precip",ylab="value")
for (i in 1:100) {
yy <- x*coef[i] + x^2*coef[i,2]
#yy <- yy - yy[x=80]
lines(x,yy,lwd=0.5)
}
