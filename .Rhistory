summary(iris)
as.data.table(iris)
iris
as.data.table(iris)
iris[Sepal.Width > 3]
iris <- as.data.table(iris)
iris[Sepal.Width > 3]
iris[Sepal.Width > 4,.(Sepal.Length, Species)]
sepal_greater_three <- iris[Sepal.Width > 3]
iris
sepal_greater_three
#give me petal.length and petal.width + 1 for every record with a sepal.length
#greater than 5 BY species
iris[Sepal.Length > 5,.(PL = sum(Petal.Length), PW = sum(Petal.Width)),.(Species)]
install.packages("extRemes")
?extRemes
?extremes
library(extRemes)
?extRemes
data(HEAT)
HEAT
?return.level
?fevd
fevd(HEAT)
fevd(HEAT[,1])
HEAT <- as.data.table(HEAT)
f_heat <- fevd(HEAT[,Tmax])
return.level(f_heat, c(5,10,50))
return.level(f_heat, c(5,15,50))
return.level(f_heat, c(1, 5,15,50))
return.level(f_heat, c(2, 5,15,50))
return.level(f_heat, c(2, 5,15,50, 200))
118/116
200 / 116
install.packages("ncdf4")
ftp://ftp.cdc.noaa.gov/Datasets/cpc_global_precip/precip.1979.nc
library(ncdf4)
download.file("ftp://ftp.cdc.noaa.gov/Datasets/cpc_global_precip/precip.1979.nc", "here.nc")
precip <- nc_open("here.nc")
precip
water <- ncvar_get(precip)
water
?ncvar_get
download.file("ftp://ftp.cdc.noaa.gov/Datasets/cpc_global_precip/precip.1990.nc", "here.nc")
precip <- nc_open("here.nc")
water <- ncvar_get(precip)
View(water)
water
install.packages("ismev")
library(ismev)
install.packages("extRemes")
install.packages("extRemes")
install.packages("extRemes")
R.home()
install.packages("ismev", lib  = "/Users/amina/anaconda2/lib/R/library")
install.packages("extRemes", lib = "/Users/amina/anaconda2/lib/R/library")
install.packages("extRemes", lib = "/Users/amina/anaconda2/lib/R/library")
install.packages("extRemes", lib = "/Users/amina/anaconda2/lib/R/library")
install.packages("mgcv", lib = "/Users/amina/anaconda2/lib/R/library")
install.packages("mgcv", lib = "/Users/amina/anaconda2/lib/R/library")
install.packages("nlme", lib = "/Users/amina/anaconda2/lib/R/library")
install.packages("nlme", lib = "/Users/amina/anaconda2/lib/R/library")
install.packages("lattice", lib = "/Users/amina/anaconda2/lib/R/library")
install.packages("lattice", lib = "/Users/amina/anaconda2/lib/R/library")
detach("package:graphics", unload=TRUE)
detach("package:grDevices", unload=TRUE)
detach("package:methods", unload=TRUE)
detach("package:stats", unload=TRUE)
detach("package:utils", unload=TRUE)
install.packages("Matrix", lib = "/Users/amina/anaconda2/lib/R/library")
install.packages(c("car", "data.table", "digest", "DT", "htmlwidgets", "lme4", "MASS", "Matrix", "mgcv", "nlme", "quantreg", "Rcpp", "RcppEigen", "rpart", "yaml"))
library("tools", lib.loc="/Library/Frameworks/R.framework/Versions/3.4/Resources/library")
install.packages("Matrix", lib = "/Users/amina/anaconda2/lib/R/library")
install.packages("Matrix", lib = "/Users/amina/anaconda2/lib/R/library")
install.packages("Matrix", lib = "/Users/amina/anaconda2/lib/R/library")
library(extRemes)
val <- 7.392210
fevd(val, verbose=T)
debug(fevd)
library(extRemes)
val <- 7.392210
fevd(val, verbose=T)
ipars2
?fevd
data <- read.csv("/Users/amina/Documents/example.csv")
data
?file.exists
?tryCatch
tryCatch(stop(e), error = function(e) e, finally = print("Hello"))
e <- 44
tryCatch(stop(e), error = function(e) e, finally = print("Hello"))
}
setwd("/Users/amina/Documents/Stanford/precip-price")
library(lfe)
#If you don't need to extract, just use this to get pp_data together
buf <- 2
rdsname <- paste0("precip/", buf, "_precip.rds")
precip <- readRDS(rdsname)
precipname <- paste0("precip/", buf, "_ppdata.csv")
##### Data Cleaning #####
#Clean up the precip data a little bit
clean_precip <- function(precip) {
precip$date <- as.Date(precip$date, format = "%Y.%m.%d")
precip$month <-  format(precip$date, "%m")
precip$year <- format(precip$date, "%Y")
precip <- precip[which(!is.na(precip$temp_mean)),]
precip <- precip %>% filter(format(precip$date, "%Y") > 1993) %>% rename(avg_rainfall = temp_mean)
pp_data <- left_join(price, precip, by = c("month", "market" = "location", "year"))
pp_data <- pp_data %>% filter(!is.na(avg_rainfall)) %>% filter(!is.na(value)) %>% filter(def_value != 0)
pp_data$yrmnth <- paste0(pp_data$year, " ", pp_data$month)
return(pp_data)
}
pp_data <- clean_precip(precip)
#divide deflation by 100, then devide rpie y that
#run log of the converted value not the usd con#pp_data <- clean_precip(precip)
#### Set of functions for standardizing regression runs
##correctly filter out the data for analysis
filter_grain <- function(data, grain) {
if(grain == "Sorghum") {
dta <- data[str_detect(data$product, "Sorghum"),]
dta <- dta[!str_detect(dta$product, "Sorghum Flour"),]
} else if(grain == "Millet") {
dta <- data[str_detect(data$product, "Millet"),]
} else if(grain == "Maize") {
dta <- data[str_detect(data$product, "Maize"),]
dta <- dta[!str_detect(dta$product, "Meal"),]
dta <- dta %>% filter(country != "Zimbabwe")
}
return(dta)
}
##get the seasons and merge data
merge_seasons <- function(data, grn) {
szn <- read.csv("downloaded/growing_seasons.csv")
szn <- szn %>% filter(grain == grn)
merged <- left_join(data, szn)
return(merged)
}
##fix dates
#s < max == minus 1 year
#s > max == same year
filter_dates <- function(data, grn) {
breakdown <- data %>% group_by(location, product) %>%
summarize(minyear = as.Date(format(min(period_date, na.rm = T), "%m/%d/%Y"), "%m/%d/%Y"),
maxyear = as.Date(format(max(period_date, na.rm = T), "%m/%d/%Y"), "%m/%d/%Y"))
#note that these dates were chosen by checking for maximum overlap in data. Earliest date is 1 year before
#the intended time period for use in precip calculation. It is removed after precip calcs are done
dates <- switch(grn, "Sorghum" = c(as.Date("03/01/2008", "%m/%d/%Y"), as.Date("09/01/2017", "%m/%d/%Y")),
"Maize" = c(as.Date("05/02/2011", "%m/%d/%Y"), as.Date("12/27/2017", "%m/%d/%Y")),
"Millet" = c(as.Date("02/01/2010", "%m/%d/%Y"), as.Date("08/30/2018", "%m/%d/%Y")))
data_markets <- breakdown %>%
filter(minyear >= dates[1]) %>%
filter(maxyear <= dates[2])
data <- data %>% filter(period_date >= dates[1]) %>%
filter(period_date <= as.Date("01/01/2018", "%m/%d/%Y")) %>%
filter(location %in% data_markets$location)
return(data)
}
##calculate precip
calc_precip <- function(data) {
#check first to see if we've already calculated this.
calcname <- paste0("precip/calc_", buf, "_ppdata.rds")
if(file.exists(calcname)) return(readRDS(calcname))
data$p_sow <- 0
data$p_grow <- 0
data$p_harv <- 0
data$p_sup <- 0
for (i in 1:nrow(data))  {
cur_month <- as.numeric(data$month[i])
cur_yr <- as.numeric(data$year[i])
#sowing season
# if the current month is after the end of the (sowing) season, use this year.
#Otherwise use previous year's season is considered
yr <- ifelse(cur_month > data$se[i], cur_yr, cur_yr - 1)
#current logic assumes start and end dates happen in the same year
early_date <- as.Date(paste0(yr, "-", data$ss[i], "-01"), format = "%Y-%m-%d")
late_date <- as.Date(paste0(yr, "-", data$se[i], "-01"), format = "%Y-%m-%d")
rain_dates <- data %>%
filter(location == data$location[i]) %>%
filter(date >= early_date) %>%
filter(date <= late_date) %>%
group_by(country, location, product, date) %>%
summarise(avg_rainfall = mean(avg_rainfall, na.rm = T))
rain <- sum(rain_dates$avg_rainfall)
data$p_sow[i] <- rain
#growing season
yr <- ifelse(cur_month > data$ge[i], cur_yr, cur_yr - 1)
early_date <- as.Date(paste0(yr, "-", data$gs[i], "-01"), format = "%Y-%m-%d")
late_date <- as.Date(paste0(yr, "-", data$ge[i], "-01"), format = "%Y-%m-%d")
rain_dates <- data %>%
filter(location == data$location[i]) %>%
filter(date >= early_date) %>%
filter(date <= late_date) %>%
group_by(country, location, product, date) %>%
summarise(avg_rainfall = mean(avg_rainfall, na.rm = T))
rain <- sum(rain_dates$avg_rainfall)
data$p_grow[i] <- rain
#harvest season
yr <- ifelse(cur_month > data$he[i], cur_yr, cur_yr - 1)
early_date <- as.Date(paste0(yr, "-", data$hs[i], "-01"), format = "%Y-%m-%d")
late_date <- as.Date(paste0(yr, "-", data$he[i], "-01"), format = "%Y-%m-%d")
rain_dates <- data %>%
filter(location == data$location[i]) %>%
filter(date >= early_date) %>%
filter(date <= late_date) %>%
group_by(country, location, product, date) %>%
summarise(avg_rainfall = mean(avg_rainfall, na.rm = T))
rain <- sum(rain_dates$avg_rainfall)
data$p_harv[i] <- rain
# between harvest and date of sale
# we don't update year because it is the same logic as the end of harvest szn
early_date <- late_date
late_date <- as.Date(data$date[i], format = "%Y-%m-%d")
rain_dates <- data %>%
filter(location == data$location[i]) %>%
filter(date >= early_date) %>%
#notice that we got rid of the equal to for the late date. Doesn't make sense for supply chain questions
filter(date < late_date) %>%
group_by(country, location, product, date) %>%
summarise(avg_rainfall = mean(avg_rainfall, na.rm = T))
rain <- sum(rain_dates$avg_rainfall)
data$p_sup[i] <- rain
# prior month
# we don't update year because it is the same logic as the end of harvest szn
late_date <- as.Date(data$date[i], format = "%Y-%m-%d")
early_date <- seq(late_date, length = 2, by = "-1 months")[2]
rain_dates <- data %>%
filter(location == data$location[i]) %>%
filter(date >= early_date) %>%
#notice that we got rid of the equal to for the late date. Doesn't make sense for supply chain questions
filter(date < late_date) %>%
group_by(country, location, product, date) %>%
summarise(avg_rainfall = mean(avg_rainfall, na.rm = T))
rain <- sum(rain_dates$avg_rainfall)
data$p_onemonth[i] <- rain
}
#Get rid of the first year, just there for calculation purposes
data <- data %>% filter(period_date >= min(period_date) + 365)
saveRDS(data, calcname)
return(data)
}
##### REGRESSIONS #####
## regress as linear
linear_regression <- function(data, var) {
switch(var,
"p_sow" = mod_data <- felm(log(def_value) ~ p_sow | market + yrmnth, data=data),
"p_grow" = mod_data <- felm(log(def_value) ~ p_grow | market + yrmnth, data=data),
"p_harv" = mod_data <- felm(log(def_value) ~ p_harv | market + yrmnth, data=data),
"p_sup" = mod_data <- felm(log(def_value) ~ p_sup | market + yrmnth, data=data),
"p_onemonth" = mod_data <- felm(log(def_value) ~ p_onemonth | market + yrmnth, data=data))
return(mod_data)
}
##regress as quadratic
quad_regression <- function(data, var) {
switch(var,
"p_sow" = mod_data <- felm(log(def_value) ~ poly(p_sow,2,raw=T) | market + yrmnth, data=data),
"p_grow" = mod_data <- felm(log(def_value) ~ poly(p_grow,2,raw=T) | market + yrmnth, data=data),
"p_harv" = mod_data <- felm(log(def_value) ~ poly(p_harv,2,raw=T) | market + yrmnth, data=data),
"p_sup" = mod_data <- felm(log(def_value) ~ poly(p_sup,2,raw=T) | market + yrmnth, data=data),
"p_onemonth" = mod_data <- felm(log(def_value) ~ poly(p_onemonth,2,raw=T) | market + yrmnth, data=data))
return(mod_data)
}
## linear interaction model with fixed effects
linear_regression_interaction <- function(data, var) {
switch(var,
"p_sow" = mod_data <- lm(log(def_value) ~ p_sow +  p_sow * country  + as.factor(market) + as.factor(yrmnth), data=data),
"p_grow" = mod_data <- lm(log(def_value) ~ p_grow +  p_grow * country  + as.factor(market) + as.factor(yrmnth), data=data),
"p_harv" = mod_data <- lm(log(def_value) ~ p_harv +  p_harv * country  + as.factor(market) + as.factor(yrmnth), data=data),
"p_sup" = mod_data <- lm(log(def_value) ~ p_sup +  p_sup * country  + as.factor(market) + as.factor(yrmnth), data=data),
"p_onemonth" = mod_data <- lm(log(def_value) ~ p_onemonth +  p_onemonth * country  + as.factor(market) + as.factor(yrmnth), data=data))
return(mod_data)
}
##### BOOTSTRAPS #####
## linear bootstrap
bootstrap_data_lin <- function(data, mod, var, short=F, name="") {
#check to see if we've run this before. If so just return it
bootfile <- paste0("boostraps/", buf, "_linear_", name, "_", var)
if(file.exists(bootfile) && name != "") return(readRDS(bootfile))
num <- ifelse(short, 100, 1000)
x = 0:700
yy = x*mod$coefficients[1]
coef <- matrix(nrow=num,ncol=2)
ll = dim(data)[1]  #the number of observations we have in the original dataset: 6584
for (i in 1:num)  {
samp <- sample(1:ll,size=ll,replace=T)
newdata = data[samp,]
#estimate our regression y = b1*T + b2*T^2
switch(var,
"p_sow" = model <- felm(log(def_value) ~ p_sow | market + yrmnth, data=newdata),
"p_grow" = model <- felm(log(def_value) ~ p_grow | market + yrmnth, data=newdata),
"p_harv" = model <- felm(log(def_value) ~ p_harv | market + yrmnth, data=newdata),
"p_sup" = model <- felm(log(def_value) ~ p_sup | market + yrmnth, data=newdata),
"p_onemonth" = model <- felm(log(def_value) ~ p_onemonth | market + yrmnth, data=newdata))
#extract the coefficient estimates of b1 and b2 and store them in the matrix we made above
coef[i,] <- coef(model)
print(i)  #print this out so you can watch progress :)
}
#save it out for the next run if name was provided
returnlist <- list(coef, x, yy)
if(name != "") saveRDS(returnlist, bootfile)
return(returnlist)
}
##bootstrap and graph
#if you would like a saved out version, please include a name in the arguments
bootstrap_data <- function(data, mod, var, short=F, name="") {
#check to see if we've run this before. If so just return it
bootfile <- paste0("boostraps/", buf, "_quad_", name, "_", var)
if(file.exists(bootfile) && name != "") return(readRDS(bootfile))
num <- ifelse(short, 100, 1000)
x = 0:700
yy = x*mod$coefficients[1]
coef <- matrix(nrow=num,ncol=2)
ll = dim(data)[1]  #the number of observations we have in the original dataset: 6584
for (i in 1:num)  {
samp <- sample(1:ll,size=ll,replace=T)
newdata = data[samp,]
#estimate our regression y = b1*T + b2*T^2
switch(var,
"p_sow" = model <- felm(log(def_value) ~ poly(p_sow,2,raw=T) | market + yrmnth, data=newdata),
"p_grow" = model <- felm(log(def_value) ~ poly(p_grow,2,raw=T) | market + yrmnth, data=newdata),
"p_harv" = model <- felm(log(def_value) ~ poly(p_harv,2,raw=T) | market + yrmnth, data=newdata),
"p_sup" = model <- felm(log(def_value) ~ poly(p_sup,2,raw=T) | market + yrmnth, data=newdata),
"p_onemonth" = model <- felm(log(def_value) ~ poly(p_onemonth,2,raw=T) | market + yrmnth, data=newdata))
#extract the coefficient estimates of b1 and b2 and store them in the matrix we made above
coef[i,] <- coef(model)
print(i)  #print this out so you can watch progress :)
}
#save it out for the next run if name was provided
returnlist <- list(coef, x, yy)
if(name != "") saveRDS(returnlist, bootfile)
return(returnlist)
}
source('~/Documents/Stanford/R - Spring 2019/New Regressions.R')
## SORGHUM
#lets get the sorghum we want specificially & merge in seasonality
sorghum <- filter_grain(pp_data, "Sorghum")
sorghum <- merge_seasons(sorghum, "sorghum")
#get locations with the right set of dates
sorghum <- filter_dates(sorghum, "Sorghum")
#calcualte precip for correct set of dates
#doing this first because otherwise we end up with some zeros at the end
sorghum <- calc_precip(sorghum)
source('~/Documents/Stanford/R - Spring 2019/New Regressions.R')
source('~/Documents/Stanford/precip-price/New Regressions.R')
source('~/Documents/Stanford/precip-price/Functions for Analysis.R')
source('~/Documents/Stanford/precip-price/Functions for Analysis.R')
source('~/Documents/Stanford/precip-price/format_price.R')
source('~/Documents/Stanford/precip-price/Functions for Analysis.R')
## SORGHUM
#lets get the sorghum we want specificially & merge in seasonality
sorghum <- filter_grain(pp_data, "Sorghum")
sorghum <- merge_seasons(sorghum, "sorghum")
#get locations with the right set of dates
sorghum <- filter_dates(sorghum, "Sorghum")
#calcualte precip for correct set of dates
#doing this first because otherwise we end up with some zeros at the end
sorghum <- calc_precip(sorghum)
mod_sorghum_grow <- quad_regression(sorghum, "p_grow")
sorghum_grow_boot <- bootstrap_data(sorghum, mod_sorghum_grow, "p_grow")
millet <- filter_grain(pp_data, "Millet")
millet <- merge_seasons(millet, "millet")
#get locations with the right set of dates
millet <- filter_dates(millet, "Millet")
#calcualte precip for correct set of dates
#doing this first because otherwise we end up with some zeros at the end
millet <- calc_precip(millet)
head(millet)
nrow(millet)
nrow(sorghum)
mod_millet_grow <- quad_regression(millet, "p_grow")
millet_grow_boot <- bootstrap_data(millet, mod_millet_grow, "p_grow")
par=mfrow(2,2)
par(mfrow(2,2))
?par
par(mfrow=c(2,2))
x <- sorghum_grow_boot[[2]]
yy <- sorghum_grow_boot[[3]]
coef <- sorghum_grow_boot[[1]]
plot(50,xlim=c(0,1000),ylim=c(-.5,.5),las=1,xlab="precip",ylab="value")
for (i in 1:100) {
yy <- x*coef[i]# + x^2*coef[i,2]
yy <- yy - yy[x=20]
lines(x,yy,lwd=0.5)
}
#plot
x <- millet_grow_boot[[2]]
yy <- millet_grow_boot[[3]]
coef <- millet_grow_boot[[1]]
plot(50,xlim=c(0,1000),ylim=c(-.5,.5),las=1,xlab="precip",ylab="value")
for (i in 1:100) {
yy <- x*coef[i]# + x^2*coef[i,2]
yy <- yy - yy[x=20]
lines(x,yy,lwd=0.5)
}
plot(50,xlim=c(0,1000),ylim=c(-.5,.5),las=1,xlab="precip",ylab="value")
plot(50,xlim=c(0,500),ylim=c(-.5,.5),las=1,xlab="precip",ylab="value")
x <- sorghum_grow_boot[[2]]
yy <- sorghum_grow_boot[[3]]
coef <- sorghum_grow_boot[[1]]
plot(50,xlim=c(0,500),ylim=c(-.5,.5),las=1,xlab="precip",ylab="value")
for (i in 1:1000) {
yy <- x*coef[i]# + x^2*coef[i,2]
yy <- yy - yy[x=20]
lines(x,yy,lwd=0.5)
}
summary(mod_sorghum_grow)
x <- sorghum_grow_boot[[2]]
yy <- sorghum_grow_boot[[3]]
coef <- sorghum_grow_boot[[1]]
plot(50,xlim=c(0,500),ylim=c(-.5,.5),las=1,xlab="precip",ylab="value")
for (i in 1:1000) {
yy <- x*coef[i]# + x^2*coef[i,2]
yy <- yy - yy[x=20]
lines(x,yy,lwd=0.5)
}
sorghum_grow_boot
x <- sorghum_grow_boot[[2]]
yy <- sorghum_grow_boot[[3]]
coef <- sorghum_grow_boot[[1]]
plot(100,xlim=c(0,630),ylim=c(-.02, .02),las=1,xlab="Total Precipitation (mm/year)",
ylab="Log Maize Price", col = "darkolivegreen3")  #initialize plotting window again
lines(x,confint[2,])  #median estimate across bootstraps
lines(x,confint[1,],lty=2)  #lower 5th percentile
lines(x,confint[3,],lty=2)  #upper 95th percentile
plot(100,xlim=c(0,630),ylim=c(-.02, .02),las=1,xlab="Total Precipitation (mm/year)",
ylab="Log Maize Price", col = "darkolivegreen3")  #initialize plotting window again
lines(x,confint[2,])  #median estimate across bootstraps
lines(x,confint[1,],lty=2)  #lower 5th percentile
lines(x,confint[3,],lty=2)  #upper 95th percentile
par(mfrow=c(1,2))
par(mfrow=c(2,2))
#plot
x <- sorghum_grow_boot[[2]]
yy <- sorghum_grow_boot[[3]]
coef <- sorghum_grow_boot[[1]]
plot(50,xlim=c(0,500),ylim=c(-.5,.5),las=1,xlab="precip",ylab="value")
for (i in 1:1000) {
yy <- x*coef[i,] + x^2*coef[i,2]
yy <- yy - yy[x=20]
lines(x,yy,lwd=0.5)
}
par(mfrow=c(1,2))
par(mfrow=c(1,2))
#plot
x <- sorghum_grow_boot[[2]]
yy <- sorghum_grow_boot[[3]]
coef <- sorghum_grow_boot[[1]]
plot(50,xlim=c(0,500),ylim=c(-.5,.5),las=1,xlab="precip",ylab="value")
for (i in 1:1000) {
yy <- x*coef[i,] + x^2*coef[i,2]
yy <- yy - yy[x=20]
lines(x,yy,lwd=0.5)
}
plot(50,xlim=c(0,500),ylim=c(-.5,.5),las=1,xlab="precip",ylab="value")
for (i in 1:1000) {
yy <- x*coef[i] + x^2*coef[i,2]
yy <- yy - yy[x=20]
lines(x,yy,lwd=0.5)
}
plot(50,xlim=c(0,500),ylim=c(-.5,.5),las=1,xlab="precip",ylab="value")
for (i in 1:1000) {
yy <- x*coef[i] + x^2*coef[i,2]
yy <- yy - yy[x=250]
lines(x,yy,lwd=0.5)
}
plot(50,xlim=c(0,750),ylim=c(-.5,.5),las=1,xlab="precip",ylab="value")
for (i in 1:1000) {
yy <- x*coef[i] + x^2*coef[i,2]
yy <- yy - yy[x=250]
lines(x,yy,lwd=0.5)
}
source('~/Documents/Stanford/precip-price/format_price.R')
source('~/Documents/Stanford/precip-price/Functions for Analysis.R')
## SORGHUM
#lets get the sorghum we want specificially & merge in seasonality
sorghum <- filter_grain(pp_data, "Sorghum")
sorghum <- merge_seasons(sorghum, "sorghum")
#get locations with the right set of dates
sorghum <- filter_dates(sorghum, "Sorghum")
#calcualte precip for correct set of dates
#doing this first because otherwise we end up with some zeros at the end
sorghum <- calc_precip(sorghum)
mod_sorghum_grow <- quad_regression(sorghum, "p_grow")
sorghum_grow_boot <- bootstrap_data(sorghum, mod_sorghum_grow, "p_grow")
x <- sorghum_grow_boot[[2]]
yy <- sorghum_grow_boot[[3]]
coef <- sorghum_grow_boot[[1]]
plot(100,xlim=c(0,400),ylim=c(-.1,10),las=1,xlab="precip",ylab="value")
for (i in 1:100) {
yy <- x*coef[i] + x^2*coef[i,2]
#yy <- yy - yy[x=80]
lines(x,yy,lwd=0.5)
}
source('~/Documents/Stanford/precip-price/Functions for Analysis.R')
mod_sorghum_grow <- quad_regression(sorghum, "p_grow")
sorghum_grow_boot <- bootstrap_data(sorghum, mod_sorghum_grow, "p_grow")
x <- sorghum_grow_boot[[2]]
yy <- sorghum_grow_boot[[3]]
coef <- sorghum_grow_boot[[1]]
plot(100,xlim=c(0,400),ylim=c(-.1,10),las=1,xlab="precip",ylab="value")
for (i in 1:100) {
yy <- x*coef[i] + x^2*coef[i,2]
#yy <- yy - yy[x=80]
lines(x,yy,lwd=0.5)
}
mod_sorghum_grow
mod_sorghum_grow <- quad_regression(sorghum, "p_grow")
mod_sorghum_grow
r
source('~/Documents/Stanford/precip-price/Functions for Analysis.R')
mod_sorghum_grow <- quad_regression(sorghum, "p_grow")
source('~/Documents/Stanford/precip-price/Functions for Analysis.R')
mod_sorghum_grow
